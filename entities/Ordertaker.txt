CreateAllMV(){
	int index;
	char ordertakerstatusMV;
	char baggedMV;
	char dineTypeMV;
	char deliveredMV;
	char baggedMV;
	char myOTMV;
	char orderMV;
	char sixBurgerMV;
	char threeBurgerMV;
	char vegBurgerMV;
	char friesMV;
	char sodaMV;
	char tablesMV;
	char tableNoMV;
	char tokenNoMV;
	
	
	/* nextOrderTakerIndex */
	nextOrderTakerIndexMVi = CreateMV("nextOrderTakerIndex", 19);
	/* custServed */
	custServedMVi = CreateMV("custServed", 10);
	/* foodToBag */
	foodToBagMVi = CreateMV("foodToBag", 9);
	/* nextCustomerIndex */
	nextCustomerIndexMVi = CreateMV("nextCustomerIndex", 17);
	/* custLineLength */
	custLineLengthMVi = CreateMV("custLineLength", 14);
	/* managerLineLength */
	managerLineLengthMVi = CreateMV("managerLineLength", 17);
	/* tableAvailable */
	tableAvailableMVi = CreateMV("tableAvailable", 14);
	/* nextTokenNumber */
	nextTokenNumberMVi = CreateMV("nextTokenNumber", 15);
	/* moneyAtRestaurant */
	moneyAtRestaurantMVi = CreateMV("moneyAtRestaurant", 17);
	
	
	/* foodReadyData.sixBurger */
	readySixBurgerMVi = CreateMV("readySixBurger", 14);
	/* foodReadyData.threeeBurger */
	readyThreeBurgerMVi = CreateMV("readyThreeBurger", 16);
	/* foodReadyData.vegBurger */
	readyVegBurgerMVi = CreateMV("readySixVegBurger", 17);
	/* foodReadyData.fries */
	readyFriesMVi = CreateMV("readyFries", 10);

	/* foodToBeCookedData.sixBurger */
	toBeCookedSixburgerMVi = CreateMV("toBecookedSixBurger", 19);
	/* foodToBeCookedData.threeBurger */
	toBeCookedThreeburgerMVi = CreateMV("toBecookedThreeBurger", 21);
	/* foodToBeCookedData.vegBurger */
	toBeCookedVegburgerMVi = CreateMV("toBecookedVegBurger", 19);
	/* foodToBeCookedData.fries */
	toBeCookedFriesMVi = CreateMV("toBecookedFriesBurger", 21);
	
	
	for(index = 1; index <= OT_COUNT; index++){
		/* orderTakerStatus[index] */
		sprintf(ordertakerstatusMV,"ordertakerstatus[%d]", index);
		ordertakerstatusMVi[index] = CreateMV(ordertakerstatusMV, 19);
	}
	for(index = 1; index <= CUST_COUNT; index++){
		/* custData[index].bagged */
		sprintf(baggedMV, "baggedincustDB[%d]", index);
		baggedincustDBMVi[index] = CreateMV(baggedMV, 18);
		/* custData[index].dineType */
		sprintf(dineTypeMV, "dineTypeincustDB[%d]", index);
		dineTypeincustDBMVi[index] = CreateMV(dineTypeMV, 20);
		/* custData[index].dilivered */
		sprintf(deliveredMV, "deliveredincustDB[%d]", index);
		deliveredincustDBMVi[index] = CreateMV(deliveredMV, 21);
		/* baggedlist[index] */
		sprintf(baggedMV, "baggedlist[%d]" index);
		baggedListMVi[index] = CreateMV(baggedMV, 14);
		/* custData[index].myOT */
		sprintf(myOTMV, "myOTincustDB[%d]", index);
		myOTMVi[index] = CreateMV(myOTMV, 16);
		/* custData[index].ordered */
		sprintf(orderedMV, "orderedincustDB[%d]", index);
		orderedincustDBMVi[index] = CreateMV(orderedMV, 16);
		/* custData[index].sixBurger/threeBurger/etc. */
		sprintf(sixBurgerMV, "sixBurgerincustDB[%d]", index);
		sixBurgerincustDBMVi[index] = CreateMV(sixBurgerMV, 21);
		sprintf(threeBurgerMV, "threeBurgerincustDB[%d]", index);
		threeBurgerincustDBMVi[index] = CreateMV(threeBurgerMV, 23);
		sprintf(vegBurgerMV, "vegBurgerincustDB[%d]", index);
		vegBurgerincustDBMVi[index] = CreateMV(vegBurgerMV, 21);
		sprintf(friesMV, "friesincustDB[%d]", index);
		friesincustDBMVi[index] = CreateMV(friesMV, 17);
		sprintf(sodaMV, "sodaincustDB[%d]", index);
		sodaincustDBMVi[index] = CreateMV(sodaMV, 16);
		/* custData[Index].tokenNo/tableNo */
		sprintf(tokenNoMV, "tokenNoincustDB[%d]", index);
		tokenNoincustDBMVi[index] = CreateMV(tokenNoMV, 19);
		sprintf(tableNoMV, "tableNoincustDB[%d]", index);
		tableNoincustDBMVi[index] = CreateMV(tableNoMV, 19);
	}
	/* tables[index] */
	for(index = 1; index <= TABLE_COUNT; index++){ 
		sprintf(tablesMV, "tables[%d]" index);
		tablesMVi[index] = CreateMV(tablesMV, 9);
	}

}

int BagTheOrders()
{
	int index = 0;	
	int cannotBeBagged = 0;

	/* if there are no more customers in the customer line */
	/* then Order Taker starts bagging the orders */
	for(index = 1; index <= CUST_COUNT; index++){
		cannotBeBagged = 0;
		Acquire(customerDataLock);
		/* check for all the orders which are not bagged */
		if(GetMV(baggedincustDBMVi[index]) != 1)
		{
			if(GetMV(sixBurgerincustDBMVi[index]) == 1)
			{
				Release(customerDataLock);
				/*if six$burgers available */
				Acquire(foodReadyDBLock);
				if(GetMV(readySixBurgerMVi) != 0)
				{
					Release(foodReadyDBLock);
					/*reserve a burger for this customer */
					Acquire(customerDataLock);
					SetMV(sixBurgerincustDBMVi[index], 2);
					Release(customerDataLock);
					/* if greater than minimum amount of cooked food */
					/* then bag it, no worries */
					Acquire(foodReadyDBLock);
					if(GetMV(readySixBurgerMVi) > MINCOOKEDFOOD)
					{
						tempV = GetMV(readySixBurgerMVi) - 1;
						SetMV(readySixBurgerMVi, tempV);
						Release(foodReadyDBLock);
						Acquire(foodToBeCookedDBLock);
						tempV = GetMV(toBeCookedSixburgerMVi) - 1;
						SetMV(toBeCookedSixburgerMVi, tempV);
						Release(foodToBeCookedDBLock);
					}
					/* else if it is less than minimum then  */
					/* bag it and increment the food to be cooked */
					else{
						tempV = GetMV(readySixBurgerMVi) - 1;
						SetMV(readySixBurgerMVi, tempV);
						Release(foodReadyDBLock);
						/* Do not decrement the foodtoBeCookedData because the */
						/* amount of cooked food is less than minimum */
					}
				}
				else if(GetMV(readySixBurgerMVi) == 0){
					cannotBeBagged = 1;
					Release(foodReadyDBLock);
				}
			}else
				Release(customerDataLock);
				
				/* if 3$burger is ordered */
				Acquire(customerDataLock);
				if(GetMV(threeBurgerincustDBMVi[index]) == 1)
				{
					Release(customerDataLock);
					/*if three$burgers available */
					Acquire(foodReadyDBLock);
					if(GetMV(readyThreeBurgerMVi) != 0)
					{
						Release(foodReadyDBLock);
						/*reserve a burger for this customer */
						Acquire(customerDataLock);
						SetMV(threeBurgerincustDBMVi[index], 2);
						Release(customerDataLock);
						/* if greater than minimum amount of cooked food */
						/* then bag it, no worries */
						Acquire(foodReadyDBLock);
						if(GetMV(readyThreeBurgerMVi) > MINCOOKEDFOOD)
						{
							tempV = GetMV(readyThreeBurgerMVi) - 1;
							SetMV(readyThreeBurgerMVi, tempV);
							Release(foodReadyDBLock);
							Acquire(foodToBeCookedDBLock);
							tempV = GetMV(toBeCookedThreeburgerMVi) - 1;
							SetMV(toBeCookedThreeburgerMVi, tempV);
							Release(foodToBeCookedDBLock);
						}
						/* else if it is less than minimum then  */
						/* bag it and do not decrement the food to be cooked */
						else{
							tempV = GetMV(readyThreeBurgerMVi) - 1;
							SetMV(readyThreeBurgerMVi, tempV);
							Release(foodReadyDBLock);
							/* Do not decrement the foodtoBeCookedData because the */
							/* amount of cooked food is less than minimum */
						}
					}
					else if(GetMV(readyThreeBurgerMVi) == 0)
					{
						cannotBeBagged = 1;
						Release(foodReadyDBLock);
					}	
				}else
					Release(customerDataLock);

				/* if vegburger is ordered */
				Acquire(customerDataLock);
				if(vegBurgerincustDBMVi[index] == 1)
				{
					Release(customerDataLock);
					/*if vegburgers available */
					Acquire(foodReadyDBLock);
					if(GetMV(readyVegBurgerMVi) != 0)
					{
						Release(foodReadyDBLock);
						/*reserve a burger for this customer */
						Acquire(customerDataLock);
						SetMV(vegBurgerincustDBMVi[index],2);
						Release(customerDataLock);
						/* if greater than minimum amount of cooked food */
						/* then bag it, no worries */
						Acquire(foodReadyDBLock);
						if(GetMV(readyVegBurgerMVi) > MINCOOKEDFOOD)
						{
							tempV = GetMV(readyVegBurgerMVi) - 1;
							SetMV(readyVegBurgerMVi, tempV);
							Release(foodReadyDBLock);
							Acquire(foodToBeCookedDBLock);
							tempV = GetMV(toBeCookedVegburgerMVi) - 1;
							SetMV(toBeCookedVegburgerMVi, tempV);
							Release(foodToBeCookedDBLock);
						}
						/* else if it is less than minimum then  */
						/* bag it and do not decrement the food to be cooked */
						else{
							tempV = GetMV(readyVegBurgerMVi) - 1;
							SetMV(readyVegBurgerMVi, tempV);
							Release(foodReadyDBLock);
							/* Do not decrement the foodtoBeCookedData because the */
							/* amount of cooked food is less than minimum */
						}
					}
					else if(GetMV(readyVegBurgerMVi) == 0)
					{
						cannotBeBagged = 1;
						Release(foodReadyDBLock);
					}
				}else
					Release(customerDataLock);
	
				/* if fries is ordered */
				Acquire(customerDataLock);
				if(GetMV(friesincustDBMVi[index]) == 1)
				{
					Release(customerDataLock);
					/*if fries available */
					Acquire(foodReadyDBLock);
					if(GetMV(readyFriesMVi) != 0)
					{
						Release(foodReadyDBLock);
						/*reserve a fries for this customer */
						Acquire(customerDataLock);
						SetMV(friesincustDBMVi[index], 2);
						Release(customerDataLock);
						/* if greater than minimum amount of cooked food */
						/* then bag it, no worries */
						Acquire(foodReadyDBLock);
						if(GetMV(readyFriesMVi) > MINCOOKEDFOOD)
						{
							tempV = GetMV(readyFriesMVi) - 1;
							SetMV(readyFriesMVi, tempV);
							Release(foodReadyDBLock);
							Acquire(foodToBeCookedDBLock);	
							tempV = GetMV(toBeCookedFriesMVi) - 1;
							SetMV(toBeCookedFriesMVi, tempV);
							Release(foodToBeCookedDBLock);
						}
						/* else if it is less than minimum then */
						/* bag it and do not decrement the food to be cooked */
						else{
							tempV = GetMV(readyFriesMVi) - 1;
							SetMV(readyFriesMVi, tempV);
							Release(foodReadyDBLock);
							/* Do not decrement the foodtoBeCookedData because the */
							/* amount of cooked food is less than minimum */
						}
					}
					else if(GetMV(readyFriesMVi) == 0){
						cannotBeBagged = 1;
						Release(foodReadyDBLock);
					}
				}else
					Release(customerDataLock);
				
				if(cannotBeBagged == 1)
				{
					continue;
				}else if(cannotBeBagged == 0)
				{					
					/* Order is bagged so update the food to bag count */
					Acquire(foodToBagLock);
					tempV = GetMV(foodToBagMVi) - 1;
					SetMV(foodToBagMVi, tempV);
					Release(foodToBagLock);
					/* make the customer order status as bagged */
	
/*CHANGE ============*/	Acquire(BagTheOrdersLock);
					SetMV(baggedincustDBMVi[index], 1);
/*CHANGE============*/	Release(BagTheOrdersLock);
					
					return (index);
				}
		}
		else
		{
				Release(customerDataLock);
		}
	}	
	return -1;


}


void OrderTaker(){
	typedef struct{
			int sixBurger;   /* Costs 6$	/* value = 0 -> not ordered */
			int threeBurger; /* Costs 3$ 	   value = 1 -> ordered */
			int vegBurger;    /* Costs 8$	   value = 2 -> item is reserved */
			int fries;        /* Costs 2$	*/
			int soda;         /* Costs 1$	*/
			int dineType;    /* Type of service the customer has opted for */
							  /* - Eat-in = 0 */
							  /* - To-go  = 1 */   
			int ordered;		  /* set if he already take the order */
			
			int myOT;		  /* index of the OrderTaker servicing the customer */
			int tokenNo;	  /* Unique number which identifies the order  */
							  /* of the current customer */
			int tableNo;	  /* where the eat-in customer is seated	 */
			int bagged;		  /* set if order is bagged by Order Taker	 */
			int delivered;	  /* set if the order is bagged and delivered */
		}custDB; 	
	custDB custData[100]
	
	int index = 0, indexj = 0;	/* index for looping through customer database	*/
	int custIndex = 0;			/* to store the cust index who being served 	*/
	int custHasToWait = 0;		/* if to-go and food not ready set this flag	*/
	int billAmount = 0;			/* to store the bill amount payed by customer	*/
	int myIndex = 0;


	int nextOrderTakerIndexMVi = 0;
	int tempV = 0; 
	int nextCustomerIndexMVi = 0;
	int custServed = 0; 
	int custServedMVi = 0;
	int custLineLength = 0;
	int custLineLengthMVi = 0;
	int managerLineLengthMVi = 0;
	int ordertakerstatusMVi[OT_COUNT] = 0;
	int ordertakerstatus[OT_COUNT] = 0;
	int tableAvailableMVi = 0;
	int foodToBag = 0; 
	int foodToBagMVi = 0;
	int baggedincustDBMVi[CUST_COUNT] = 0;
	int dineTypeincustDBMVi[CUST_COUNT] = 0;
	int deliveredincustDBMVi[CUST_COUNT] = 0;
	int baggedList[CUST_COUNT] = 0;
	int baggedListMVi[CUST_COUNT] = 0;
	int myOTMVi[CUST_COUNT] = 0;
	int orderedincustDBMVi[CUST_COUNT] = 0;
	int sixBurgerincustDBMVi[CUST_COUNT] ;
	int threeBurgerincustDBMVi[CUST_COUNT] ;
	int vegBurgerincustDBMVi[CUST_COUNT] ;
	int friesincustDBMVi[CUST_COUNT] ;
	int sodaincustDBMVi[CUST_COUNT] ; 
	int tokenNoincustDBMVi[CUST_COUNT];
	int tableNoincustDBMVi[CUST_COUNT];
	int tablesMVi[TABLE_COUNT];
	int readySixBurgerMVi;
	int readyThreeBurgerMVi;
	int readyVegBurgerMVi;
	int readyFriesMVi;
	int toBeCookedSixburgerMVi;
	int toBeCookedThreeburgerMVi;
	int toBeCookedVegburgerMVi;
	int toBeCookedFriesMVi;	
	int nextTokenNumberMVi;
	int moneyAtRestaurantMVi;
	
	CreateAllMV();
	
	/* Get the Index for this Customer before starting the order */
	Acquire(nextOrderTakerIndexLock);
	
	myIndex = GetMV(nextOrderTakerIndexMVi);
	tempV = myIndex + 1;
	SetMV(nextOrderTakerIndexMVi, tempV);
	
	Release(nextOrderTakerIndexLock);
	
	while(1)
	{
		Acquire(custServedLock);
		
		custServed = GetMV(custServedMVi);
		if(custServed == CUST_COUNT){
			Release(custServedLock);
				/* @ */
				/* Print_1Arg("OrderTaker %d calling E---X--I---T\n$", myIndex); */
				Exit(0);
		}
		Release(custServedLock);
		/* Acquire custLineLock to access the custLineLength monitor variable	*/
		Acquire(custLineLock);
		/* Check for any customers waiting in the customer waiting line	*/
		
		custLineLength = GetMV(custLineLengthMVi);
		
		if(custLineLength > 0){
			/* customers are available so I am releasing the food to bag lock	*/	
			/* There are customers in the customer waiting line	*/
			/* Signal a customer which indicates the customer to come out of	*/
			/* the waiting line and give his order	*/
			Signal(custLineCV, custLineLock);
			
			/* Decrement the custLineLength moniter variable value by 1	*/
			custLineLength--;
			SetMV(custLineLengthMVi, custLineLength);
			
			/* Before releasing the custLineLock, 	*/
			/* Order Taker changes his status to WAITING	*/
			SetMV(ordertakerstatusMVi[myIndex], OT_WAIT);
			
			Release(custLineLock);
		}		
		else{ 
			Release(custLineLock);
			/* Acquire the foodToBagLock to check if there are any orders to bag	*/
			Acquire(foodToBagLock);
		
			foodToBag = GetMV(foodToBagMVi);
		
			if(foodToBag > 0){
				/* If No customers in the customer waiting line and	*/
				/* if there is some food to bag	*/
			
				/* bag 1 at a time	*/
				/* index of the customer whose order was bagged is returned	*/
				Release(foodToBagLock);
				
				Acquire(BagTheOrdersLock);
				index = BagTheOrders();
				if(index > 0){
					/* OG	*/
					Print_2Arg("OrderTaker %d packed the food for Customer %d\n$", myIndex, index);
					
					custData[index].bagged = 1;
					SetMV(baggedincustDBMVi,custData[index].bagged);

					Release(BagTheOrdersLock);
					/* after bagging an order 	*/
					/* if the customer has chosen to-go then broadcast the signal	*/
					/* for the customers waiting in the toGoWaiting line	*/
					custData[index].dineType = GetMV(dineTypeincustDBMVi);
					
					if(custData[index].dineType == 1){
						/* Acquire the Lock which is used to match with To-go	*/
						/* waiting condition variable waitingLock	*/
						Acquire(waitToGoLock);
						Broadcast(toGoCV, waitToGoLock);
						Release(waitToGoLock);	
						
						/* set the broadcastedTokenNo monitor variable to the	*/
						/* tokenNo of the customer whose order was bagged	*/
						Acquire(customerDataLock);
						
						custData[index].bagged = GetMV(baggedincustDBMVi[index]);

						if(custData[index].bagged == 1){
						
							custData[index].delivered = 1;
							SetMV(deliveredincustDBMVi[index], custData[index].delivered);
						
						}	
						/* Order Taker Broadcasts the signal to all to-go waiting	*/
						Release(customerDataLock);
						
						/* Release the waiting line Lock so that the customers	*/
						/* who received the signal can acquire the Lock and compare	*/
						/* their tokenNo with the broadcastedTokenNo	*/
						
					}
					/* else if the customer has chosen to eat-in then the tokenNo 	*/
					/* of the order which is bagged is added to the baggedList 	*/
					/* from which the waiter will remove the tokenNo and 	*/
					/* deliver it to the eat-in seated customer 	*/
					else if(custData[index].dineType == 0){
						/* Acquire the Lock to Append the tokenNo to the 	*/
						/* bagged List		*/
/*CHANGE============*/	Acquire(BagTheOrdersLock);	
						custData[index].bagged = 1;
						
						SetMV(baggedincustDBMVi,custData[index].bagged);
						
/*CHANGE============*/	Release(BagTheOrdersLock);
						Acquire(foodBaggedListLock);
						for(indexj = 1; indexj <= CUST_COUNT; indexj++){
							
							baggedList[indexj] = GetMV(baggedListMVi[indexj]);
							
							if(baggedList[indexj] == 0){
								
								baggedList[indexj] = custData[index].tokenNo;
								SetMV(baggedListMVi[indexj], baggedList[indexj]);
								
								break;
							}
						}
						/* OG	*/
						Print_3Arg("Ordertaker %d gives Token number %d to Waiter for Customer %d\n$", myIndex, custData[index].tokenNo, index);
						Release(foodBaggedListLock);
					}
				}
		   		Release(BagTheOrdersLock);	
				Yield(); 
			} 
			
			else{
				/* no customers are available and no food to bag so	*/
				/* releasing the food to bag lock	*/
				Release(foodToBagLock);
				/* No customers to serve and no food to bag so the Order Taker 	*/
				/* has nothing to do, Set the status of that Order Taker as FREE	*/
				/* Check if all the Customers are serviced	*/
				Acquire(custServedLock);
				if(GetMV(custServedMVi) == CUST_COUNT){
					Release(custServedLock);
					Print_1Arg("OrderTaker %d calling E---X---I---T\n$", myIndex);
					Exit(0);
				}
				Release(custServedLock);
				Acquire(custLineLock);
				
				SetMV(ordertakerstatusMVi[myIndex], OT_FREE);
				
				Release(custLineLock);
			}		
		}
				
		if((GetMV(ordertakerstatusMVi[myIndex]) == OT_WAIT) || (GetMV(ordertakerstatusMVi[myIndex]) == OT_WAIT))
		{
			/* Acquire the orderTakerLock before releasing the custLineLock 	*/
			/* - To ensure that the Customer acquires the orderTakerLock 	*/
			/*   after Order Taker does	*/
			Acquire(orderTakerLock[myIndex]);
			/*Release the custLineLock 	*/
			/* - so that the Customer can access the updated status of the Order Taker	*/
		    /* @ */
			/* Print_1Arg("OrderTaker %d is waiting\n$", myIndex); */
			
			/* Order Taker goes on wait to receive a signal from the Customer 	*/
			/* which indicates Customer is ready to place the order	*/
			Wait(orderTakerCV[myIndex], orderTakerLock[myIndex]);
		 	Release(orderTakerLock[myIndex]);
			Acquire(custServedLock);
			if(GetMV(custServedMVi) == CUST_COUNT){
				Release(custServedLock);
				/* @ */
				/* Print_1Arg("OrderTaker %d calling E---X---I---T\n$", myIndex); */
				Exit(0);
			}
			Release(custServedLock);

			Acquire(orderTakerLock[myIndex]);
			
			/* Send a signal to the Customer which indicates that the Order Taker	*/
			/* is ready to take the order	*/
			Signal(orderTakerCV[myIndex], orderTakerLock[myIndex]);
			
			/* Order Taker will go on wait till he receives a signal from the 	*/
			/* customer after placing the order	*/
			Wait(orderTakerCV[myIndex], orderTakerLock[myIndex]);
			Release(orderTakerLock[myIndex]);
			
			Acquire(custServedLock);
			if(GetMV(custServedMVi) == CUST_COUNT){
				Release(custServedLock);
				/* @ */
				/* Print_1Arg("OrderTaker %d calling E---X---I---T\n$", myIndex); */
				Exit(0);
			}
			Release(custServedLock);		
		
			/* Received a signal from the customer after placing an order 	*/
			/* Find the customer index once the order is placed	*/
			Acquire(customerDataLock);
			for( index = 1; index <= CUST_COUNT; index++){
				/* find the customer index by finding the customer who has their Order	*/
				/* taker index as the current Order taker Index Thread	*/
				if(GetMV(myOTMVi[index]) == myIndex){
					if(GetMV(orderedincustDBMVi[index]) != 1){
						custIndex = index;
						SetMV(orderedincustDBMVi[index], 1);
						break;
					}
				}
			}
			Release(customerDataLock);

			/* OG	*/
			Print_2Arg("OrderTaker %d is taking order of Customer %d\n$", myIndex, custIndex);
			
			/* if to-go customer then  - to check if the food is ready right away	*/
			/*						   - if not ready then make customer wait	*/
			/*						   - modify the food required monitor variable	*/
			if(GetMV(dineTypeincustDBMVi[custIndex]) == 1){
				custHasToWait = 0;
				/* if 6$burger is ordered*/
				Acquire(customerDataLock);
				if(GetMV(sixBurgerincustDBMVi[custIndex]) == 1){
					Release(customerDataLock);
					/* if 6$burger is ready	*/
					Acquire(foodReadyDBLock);
					if(GetMV(readySixBurgerMVi) != 0){
						Release(foodReadyDBLock);
						/*reserve a burger for this customer	*/
						Acquire(customerDataLock);
						SetMV(sixBurgerincustDBMVi[custIndex],2);
						Release(customerDataLock);
						/* if greater than minimum amount of cooked food	*/
						/* then bag it, no worries	*/
						Acquire(foodReadyDBLock);
						if(GetMV(readySixBurgerMVi) > MINCOOKEDFOOD){
							tempV = GetMV(readySixBurgerMVi) - 1;
							SetMV(readySixBurgerMVi, tempV);
							Release(foodReadyDBLock);
							Acquire(foodToBeCookedDBLock);
							tempV = GetMV(toBeCookedSixburgerMVi) - 1;
							SetMV(toBeCookedSixburgerMVi, tempV)
			
							Release(foodToBeCookedDBLock);
						}
							else{
							/* else if it is less than minimum then 	*/
							/* bag it and increment the food to be cooked	*/
							tempV = GetMV(readySixBurgerMVi) - 1;
							SetMV(readySixBurgerMVi, tempV);

								Release(foodReadyDBLock);
								/* Do not decrement the foodtoBeCookedData because the	*/
								/* amount of cooked food is less than minimum	*/
							}
						}	
						else{ /* customer has to wait	*/
							custHasToWait = 1;
							Release(foodReadyDBLock);
						}
					}
					else
						Release(customerDataLock);
	
				/* if 3$burger is ordered	*/
				Acquire(customerDataLock);
				if(GetMV(threeBurgerincustDBMVi[custIndex]) == 1){
					Release(customerDataLock);
					/* if 3$burger is ready	*/
					Acquire(foodReadyDBLock);
					if(GetMV(readyThreeBurgerMVi) != 0){
						Release(foodReadyDBLock);
						/*reserve a burger for this customer	*/
						Acquire(customerDataLock);
						SetMV(threeBurgerincustDBMVi[custIndex],2);
						Release(customerDataLock);
						/* if greater than minimum amount of cooked food	*/
						/* then bag it, no worries	*/
						Acquire(foodReadyDBLock);
						if(GetMV(readyThreeBurgerMVi) > MINCOOKEDFOOD){
						tempV = GetMV(readyThreeBurgerMVi) - 1;
						SetMV(readyThreeBurgerMVi, tempV);
						Release(foodReadyDBLock);
						Acquire(foodToBeCookedDBLock);
						
						tempV = GetMV(toBeCookedThreeburgerMVi) - 1;
						SetMV(toBeCookedThreeburgerMVi, tempV);

						Release(foodToBeCookedDBLock);
						}
						/* else if it is less than minimum then 	*/
						/* bag it and do not decrement the food to be cooked	*/
						else{
						tempV = GetMV(readyThreeBurgerMVi) - 1;
						SetMV(readyThreeBurgerMVi, tempV);
							Release(foodReadyDBLock);
							/* Do not decrement the foodtoBeCookedData because the	*/
							/* amount of cooked food is less than minimum	*/						
						}						
					}	
					else{ /* customer has to wait	*/
							custHasToWait = 1;
							Release(foodReadyDBLock);
					}
				}
				else
					Release(customerDataLock);
				
				/* if vegburger is ordered	*/
				Acquire(customerDataLock);
				if(GetMV(vegBurgerincustDBMVi[custIndex]) == 1){
					Release(customerDataLock);
					/* if vegburger is ready	*/
					Acquire(foodReadyDBLock);
					if(GetMV(readyVegBurgerMVi) != 0){
					Release(foodReadyDBLock);
						/*reserve a burger for this customer*/
						Acquire(customerDataLock);
						SetMV(vegBurgerincustDBMVi[custIndex], 2);
						Release(customerDataLock);
						/* if greater than minimum amount of cooked food	*/
						/* then bag it, no worries	*/
						Acquire(foodReadyDBLock);
						if(GetMV(readyVegBurgerMVi) > MINCOOKEDFOOD){
							tempV = GetMV(readyVegBurgerMVi) - 1;
							SetMV(readyVegBurgerMVi, tempV);
							
							Release(foodReadyDBLock);
							Acquire(foodToBeCookedDBLock);
							tempV = GetMV(toBeCookedVegburgerMVi) - 1;
							SetMV(toBeCookedVegburgerMVi, tempV);
							Release(foodToBeCookedDBLock);
						}
						/* else if it is less than minimum then 	*/
						/* bag it and do not decrement the food to be cooked	*/
						else{
							tempV = GetMV(readyVegBurgerMVi) - 1;
							SetMV(readyVegBurgerMVi, tempV);
							Release(foodReadyDBLock);
							/* Do not decrement the foodtoBeCookedData because the	*/
							/* amount of cooked food is less than minimum	*/
						}	
					}
					else {/* customer has to wait	*/
						custHasToWait = 1;
						Release(foodReadyDBLock);
					}
				}
				else
					Release(customerDataLock);
				
				/* if fries is ordered	*/
				Acquire(customerDataLock);
				if(GetMV(friesincustDBMVi[custIndex]) == 1){
				Release(customerDataLock);
					/* if fries is ready	*/
					Acquire(foodReadyDBLock);
					if(GetMV(readyFriesMVi) != 0){
					Release(foodReadyDBLock);
						/*reserve a fries for this customer	*/
						Acquire(customerDataLock);
						SetMV(friesincustDBMVi[custIndex], 2);
						Release(customerDataLock);
						/* if greater than minimum amount of cooked food	*/
						/* then bag it, no worries	*/
						Acquire(foodReadyDBLock);
						if(GetMV(readyFriesMVi) > MINCOOKEDFOOD){
							tempV = GetMV(readyFriesMVi) - 1;
							SetMV(readyFriesMVi, tempV);
							Release(foodReadyDBLock);
							Acquire(foodToBeCookedDBLock);
							tempV = GetMV(toBeCookedFriesMVi) - 1;
							SetMV(toBeCookedFriesMVi, tempV);
							Release(foodToBeCookedDBLock);
						}
						/* else if it is less than minimum then 	*/
						/* bag it and do not decrement the food to be cooked	*/
						else{
							tempV = GetMV(readyFriesMVi) - 1;
							SetMV(readyFriesMVi, tempV);
							Release(foodReadyDBLock);							
							/* Do not decrement the foodtoBeCookedData because the	*/
							/* amount of cooked food is less than minimum	*/
						}		
					}
					else{ /* customer has to wait	*/
						custHasToWait = 1;
						Release(foodReadyDBLock);
					}
				}
				else 
					Release(customerDataLock);
	
				/* if to-go and if customer has to wait	*/
				if(custHasToWait == 1){
					/* set the token number for the customer	*/
					/* Acquire the lock to get the next token number to be given 	*/
					/* to the customer, all Order Takers access this value	*/
					/* - increment this monitor variable to generate the new unique	*/
					/*   token number and give it to customer	*/
					Acquire(nextTokenNumberLock);
					tempV = GetMV(nextTokenNumberMVi) + 1;
					SetMV(nextTokenNumberMVi,tempV);
					SetMV(tokenNoincustDBMVi[custIndex],GetMV(nextTokenNumberMVi))
					
					/* Release the lock after obtaining the new token number	*/
					Release(nextTokenNumberLock);
					/* Acquire the foodToBagLock to increment the foodToBag count	*/
					Acquire(foodToBagLock);
					tempV = GetMV(foodToBagMVi) + 1;
					SetMV(foodToBagMVi, tempV);
					/* Release the foodToBagLock after updating the foodToBag count	*/
					Release(foodToBagLock);
					
					/* OG	*/
					Print_3Arg("OrderTaker %d gives token number %d to TOGO Customer %d\n$", myIndex, custData[custIndex].tokenNo, custIndex);
				}else{
					/* food is ready and can be bagged	*/
					/* Even if the customer has ordered only soda	*/
					/* it is bagged here	*/
					/* Order is bagged so update the food to bag count
	
/*CHANGE============*/	Acquire(BagTheOrdersLock);					
					/* make the customer order status as bagged	*/
					SetMV(baggedincustDBMVi[custIndex], 1);
/*CHANGE ============*/	Release(BagTheOrdersLock);					
/*CHANGE============*/	Acquire(customerDataLock);
					SetMV(deliveredincustDBMVi[custIndex], 1);

					/* OG	*/
					Print_2Arg("OrderTaker %d packs and gives food to TOGOCustomer %d\n$", myIndex, custIndex);
					/* Release the foodToBagLock after updating the foodToBag count	*/
					Release(customerDataLock);
					/* Order Taker will bag only one order at a time so break	*/
				}
			}	/* dineType = to-go		*/

			if(GetMV(dineTypeincustDBMVi[custIndex]) == 0){
				custHasToWait = 0;
				/* always customer has to wait, he will not get food right away	*/
				/* set the token number for the customer	*/
				/* Acquire the lock to get the next token number to be given 	*/
				/* to the customer, all Order Takers access this value	*/
				/* - increment this monitor variable to generate the new unique	*/
				/*   token number and give it to customer	*/
				Acquire(nextTokenNumberLock);
				tempV = GetMV(nextTokenNumberMVi) + 1;
				SetMV(nextTokenNumberMVi,tempV);
				SetMV(tokenNoincustDBMVi[custIndex],GetMV(nextTokenNumberMVi))
				/* Release the lock after obtaining the new token number	*/
				/* OG	*/
				Print_3Arg("OrderTaker %d gives token number %d to EATINCustomer %d\n$", myIndex, custData[custIndex].tokenNo, custIndex);
				Release(nextTokenNumberLock);

				/* eat-in customer always waits	*/			
	
				/* Acquire the foodToBagLock to increment the foodToBag count	*/
				/* Release the foodToBagLock after updating the foodToBag count	*/
				
				/* Order taker has to update the foodToBeCooked & foodReady database	*/
				/* if 6$burger is ordered	*/
				Acquire(customerDataLock);
				if(GetMV(sixBurgerincustDBMVi[custIndex] == 1){
					Release(customerDataLock);
					/* if 6$burger is ready	*/
					Acquire(foodReadyDBLock);
					if(GetMV(readySixBurgerMVi) != 0){
					Release(foodReadyDBLock);
						/*reserve a burger for this customer	*/
						Acquire(customerDataLock);
						SetMV(sixBurgerincustDBMVi[custIndex],2);
						Release(customerDataLock);
						/* if greater than minimum amount of cooked food	*/
						/* then bag it, no worries	*/
						Acquire(foodReadyDBLock);
						if(GetMV(readySixBurgerMVi) > MINCOOKEDFOOD){
							tempV = GetMV(readySixBurgerMVi) - 1;
							SetMV(readySixBurgerMVi, tempV);
							Release(foodReadyDBLock);
							Acquire(foodToBeCookedDBLock);
							tempV = GetMV(toBeCookedSixburgerMVi) - 1;
							SetMV(toBeCookedSixburgerMVi, tempV)
							Release(foodToBeCookedDBLock);
						}
						/* else if it is less than minimum then 	*/
						/* bag it and increment the food to be cooked	*/
						else{
							tempV = GetMV(readySixBurgerMVi) - 1;
							SetMV(readySixBurgerMVi, tempV);
							Release(foodReadyDBLock);
							/* Do not decrement the foodtoBeCookedData because the	*/
							/* amount of cooked food is less than minimum	*/
						}
					}
	 				else 
						custHasToWait = 1;
						Release(foodReadyDBLock);
				}
				else
				Release(customerDataLock);
			
				/* if 3$burger is ordered	*/
				Acquire(customerDataLock);
				if(GetMV(threeBurgerincustDBMVi[custIndex]) == 1){
					Release(customerDataLock);
					/* if 3$burger is ready	*/
					Acquire(foodReadyDBLock);
					if(GetMV(readyThreeBurgerMVi) != 0){
						Release(foodReadyDBLock);
						/*reserve a burger for this customer	*/
						Acquire(customerDataLock);
						SetMV(threeBurgerincustDBMVi[custIndex],2);
						Release(customerDataLock);
						/* if greater than minimum amount of cooked food	*/
						/* then bag it, no worries	*/
						Acquire(foodReadyDBLock);
						if(GetMV(readyThreeBurgerMVi) > MINCOOKEDFOOD){
						tempV = GetMV(readyThreeBurgerMVi) - 1;
						SetMV(readyThreeBurgerMVi, tempV);
						Release(foodReadyDBLock);
						Acquire(foodToBeCookedDBLock);
						
						tempV = GetMV(toBeCookedThreeburgerMVi) - 1;
						SetMV(toBeCookedThreeburgerMVi, tempV);

						Release(foodToBeCookedDBLock);
						}
						/* else if it is less than minimum then 	*/
						/* bag it and do not decrement the food to be cooked	*/
						else{
						tempV = GetMV(readyThreeBurgerMVi) - 1;
						SetMV(readyThreeBurgerMVi, tempV);
							Release(foodReadyDBLock);
							/* Do not decrement the foodtoBeCookedData because the	*/
							/* amount of cooked food is less than minimum	*/						
						}						
					}	
					else{ /* customer has to wait	*/
							custHasToWait = 1;
							Release(foodReadyDBLock);
					}
				}
				else
					Release(customerDataLock);
					
				/* if vegburger is ordered	*/
				Acquire(customerDataLock);
				if(GetMV(vegBurgerincustDBMVi[custIndex]) == 1){
					Release(customerDataLock);
					/* if vegburger is ready	*/
					Acquire(foodReadyDBLock);
					if(GetMV(readyVegBurgerMVi) != 0){
					Release(foodReadyDBLock);
						/*reserve a burger for this customer*/
						Acquire(customerDataLock);
						SetMV(vegBurgerincustDBMVi[custIndex], 2);
						Release(customerDataLock);
						/* if greater than minimum amount of cooked food	*/
						/* then bag it, no worries	*/
						Acquire(foodReadyDBLock);
						if(GetMV(readyVegBurgerMVi) > MINCOOKEDFOOD){
							tempV = GetMV(readyVegBurgerMVi) - 1;
							SetMV(readyVegBurgerMVi, tempV);
							
							Release(foodReadyDBLock);
							Acquire(foodToBeCookedDBLock);
							tempV = GetMV(toBeCookedVegburgerMVi) - 1;
							SetMV(toBeCookedVegburgerMVi, tempV);
							Release(foodToBeCookedDBLock);
						}
						/* else if it is less than minimum then 	*/
						/* bag it and do not decrement the food to be cooked	*/
						else{
							tempV = GetMV(readyVegBurgerMVi) - 1;
							SetMV(readyVegBurgerMVi, tempV);
							Release(foodReadyDBLock);
							/* Do not decrement the foodtoBeCookedData because the	*/
							/* amount of cooked food is less than minimum	*/
						}	
					}
					else {/* customer has to wait	*/
						custHasToWait = 1;
						Release(foodReadyDBLock);
					}
				}
				else
					Release(customerDataLock);
				
				/* if fries is ordered	*/
				Acquire(customerDataLock);
				if(GetMV(friesincustDBMVi[custIndex]) == 1){
				Release(customerDataLock);
					/* if fries is ready	*/
					Acquire(foodReadyDBLock);
					if(GetMV(readyFriesMVi) != 0){
					Release(foodReadyDBLock);
						/*reserve a fries for this customer	*/
						Acquire(customerDataLock);
						SetMV(friesincustDBMVi[custIndex], 2);
						Release(customerDataLock);
						/* if greater than minimum amount of cooked food	*/
						/* then bag it, no worries	*/
						Acquire(foodReadyDBLock);
						if(GetMV(readyFriesMVi) > MINCOOKEDFOOD){
							tempV = GetMV(readyFriesMVi) - 1;
							SetMV(readyFriesMVi, tempV);
							Release(foodReadyDBLock);
							Acquire(foodToBeCookedDBLock);
							tempV = GetMV(toBeCookedFriesMVi) - 1;
							SetMV(toBeCookedFriesMVi, tempV);
							Release(foodToBeCookedDBLock);
						}
						/* else if it is less than minimum then 	*/
						/* bag it and do not decrement the food to be cooked	*/
						else{
							tempV = GetMV(readyFriesMVi) - 1;
							SetMV(readyFriesMVi, tempV);
							Release(foodReadyDBLock);							
							/* Do not decrement the foodtoBeCookedData because the	*/
							/* amount of cooked food is less than minimum	*/
						}		
					}
					else{ /* customer has to wait	*/
						custHasToWait = 1;
						Release(foodReadyDBLock);
					}
				}
				else 
					Release(customerDataLock);

				if (custHasToWait = 0){
/*CHANGE ============*/	Acquire(BagTheOrdersLock);
					SetMV(baggedincustDBMVi[custIndex],1);
/*CHANGE============*/	Release(BagTheOrdersLock);
					Acquire(foodBaggedListLock);
					for(indexj = 1; indexj <= CUST_COUNT; indexj++){	
						if(GetMV(baggedListMVi[indexj]) == 0){
						SetMV(baggedListMVi[indexj], GetMV(tokenNoincustDBMVi[index]));
						break;
						}
					}
						Print_3Arg("Ordertaker %d gives Token number %d to Waiter for Customer %d\n$", myIndex, custData[index].tokenNo, index);
						Release(foodBaggedListLock);
				}else{
					/* Acquire the foodToBagLock to increment the foodToBag count	*/
					Acquire(foodToBagLock);
					tempV = GetMV(foodToBagMVi) + 1;
					SetMV(footToBagMVi, tempV);
					/* Release the foodToBagLock after updating the foodToBag count	*/
					Release(foodToBagLock);
				}
			}
	
			Acquire(customerDataLock);
			if(GetMV(sixBurgerincustDBMVi[custIndex]) == 2){
				Release(customerDataLock);
				Acquire(foodToBeCookedDBLock);
				tempV = GetMV(toBeCookedSixburgerMVi) + 1;
				SetMV(toBeCookedSixburgerMVi, tempV);
				Release(foodToBeCookedDBLock);
			}else
				Release(customerDataLock);
			
			Acquire(customerDataLock);
			if(GetMV(threeBurgerincustDBMVi[custIndex]) == 2){
				Release(customerDataLock);
				Acquire(foodToBeCookedDBLock);
				tempV = GetMV(toBeCookedThreeburgerMVi) + 1;
				SetMV(toBeCookedThreeburgerMVi, tempV);
				Release(foodToBeCookedDBLock);
			}else
				Release(customerDataLock);
			Acquire(customerDataLock);
			if(GetMV(vegBurgerincustDBMVi[custIndex]) == 2){
				Release(customerDataLock);
				Acquire(foodToBeCookedDBLock);
				tempV = GetMV(toBeCookedVegburgerMVi) + 1;
				SetMV(toBeCookedVegburgerMVi, tempV);
				Release(foodToBeCookedDBLock);
			}else
/* CHANGE======== */Release(customerDataLock);
			
			Acquire(customerDataLock);
			if(GetMV(friesincustDBMVi[custIndex]) == 2){
				Release(customerDataLock);
				Acquire(foodToBeCookedDBLock);
				tempV = GetMV(toBeCookedFriesMVi) + 1;
				SetMV(toBeCookedFriesMVi, tempV);
				Release(foodToBeCookedDBLock);
			}else
/* CHANGE======== */Release(customerDataLock);

			Acquire(orderTakerLock[myIndex]);
			/* Send a signal to the Customer which indicates that the 	*/
			/* Order Taker has processed the order	*/
			Signal(orderTakerCV[myIndex], orderTakerLock[myIndex]);		
			/* wait for the customer to pay money	*/
			Wait(orderTakerCV[myIndex], orderTakerLock[myIndex]);
			Release(orderTakerLock[myIndex]);
			Acquire(custServedLock);
			if(GetMV(custServedMVi) == CUST_COUNT){
				Release(custServedLock);
				/* @ */
				/* Print_1Arg("OrderTaker %d calling E---X---I---T\n$", myIndex); */
				Exit(0);
			}
			
			Release(custServedLock);
			Acquire(customerDataLock);
			if(GetMV(sixBurgerincustDBMVi[custIndex]) > 0)
				billAmount += 6;	/* 6$Burger	*/
			if(GetMV(threeBurgerincustDBMVi[custIndex]) > 0)
				billAmount += 3;	/* 3$Burger	*/
			if(GetMV(vegBurgerincustDBMVi[custIndex]) > 0)
				billAmount += 8;	/* vegBurger costs 8$ */
			if(GetMV(friesincustDBMVi[custIndex]) > 0)
				billAmount += 2;	/* fries costs 2$ */
			if(GetMV(sodaincustDBMVi[custIndex]) > 0)
				billAmount += 1;	/* soda costs 1$ */
			Release(customerDataLock);
			
			Acquire(moneyAtRestaurantLock);
			tempV = GetMV(moneyAtRestaurantMVi);
			SetMV(moneyAtRestaurantMVi, tempV);
			/* release the lock after storing the money	*/
			Release(moneyAtRestaurantLock);
			/* Send a signal to the Customer which indicates that the 	*/
			/* Order Taker has processed the order	*/
			Acquire(orderTakerLock[myIndex]);
			Signal(orderTakerCV[myIndex],orderTakerLock[myIndex]);	
			/* interaction with the current customer is completed so the 	*/
			/* Order Taker releases the Lock	*/
			Release(orderTakerLock[myIndex]);
			
			Acquire(custServedLock);
			if(GetMV(custServedMVi) == CUST_COUNT){
				Release(custServedLock);
				/* @ */
				/* Print_1Arg("OrderTaker %d calling E---X---I---T\n$", myIndex); */
				Exit(0);
			}
			Release(custServedLock);	
		}
		
	}   /* While(1) 	*/
}	
	
	
	
	
	









